 // Job: highest priority first (HPF) both nonpreemptive and preemptive
#include "ready_queue.h"
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>
#include <stdbool.h>

int main(int argc, const char * argv[])
{
    srand((unsigned int)time(NULL));
	float time = 0.0f; // Starts at 0 time to allow our algorithm to run 5 times
	while(time != 5) 
	{
    int queueSize = 100; 
    struct ready_queue randomQueue = new_ready_queue(queueSizeA); // This is the one ready queue & it will generate simulated_process 
	print_ready_queue(randomQueue);
    run_schedulers(randomQueue); 
    delete_ready_queue(&randomQueue); 
	time++;
	}
    return 0;
}

void print_simulated_process(struct simulated_process printingProcess)
{
    printf("Process name: %c\n Arrival Time: %f\n Expected Run Time: %f\n Priority: %d\n", printingProcess.letter, printingProcess.arrivalTime,
           printingProcess.expectedRunTime, printingProcess.priority);
}

void print_ready_queue(struct ready_queue printingQueue)
{
    int i;
    for (i = 0;  i < printingQueue.length; i++)
    {
        printf("Process %c:\n", i + 'A');
        print_simulated_process(printingQueue.processes[i]);
        printf("\n");
    }
}

// Scheduling algorithm here
void run_schedulers(struct ready_queue runningQueue)
{
	// 1st sort simulated processes in arrival time order - using Bubblesort
	int out, in;
	int queueSize = 26; 
	struct ready_queue sorted = runningQueue; // Store runningQueue parameter into the sorted variable 
	for (out = 0; out < sorted.length; out++)
	{
		for (in = 0; in < sorted.length-1; in++)
		{
			if(sorted[in].simulated_process.arrivalTime > sorted[out+1].simulated_process.arrivalTime)
			{
				struct ready_queue arrival = sorted[in+1]; 
				sorted[in+1] = sorted[out];
				sorted[out] = arrival;
			}
		}
	}
	
    // 2nd create 4 priority queues label 1-4 priority && empty everything in it with 1 - highest 
	struct ready_queue priority1 = new_ready_queue(queueSize); 
    struct ready_queue priority2 = new_ready_queue(queueSize);	
	struct ready_queue priority3 = new_ready_queue(queueSize);
	struct ready_queue priority4 = new_ready_queue(queueSize);
	
	// 3rd With 'sort' completed, take the 1st element/process from sort, determine its priority and place it into the matching priority queue.   
	
	for(int i = 0; i <= queueSize; i++) // Go through entire sort 
	{
		if(sorted[i].process.priority == 1) // Get the process within the sort and see if the process's priority matches the priority's queue number  
		{
			priority1.add(sort[i]); // if their process's priority number is equal to 1, then add that process into the priority1 queue 
			sorted.remove(sorted[i]); // Since that priority is placed into the priority1 queue , remove it from the sort queue 
		}
		else if(sorted[i].process.priority == 2)
		{
			priority2.add(sorted[i]);
			sorted.remove(sorted[i]);
		}
		else if(sorted[i].process.priority == 3)
		{
			priority3.add(sorted[i]);
			sorted.remove(sorted[i]);
		}
		else // else the process's priority is 4
		{
			priority4.add(sorted[i]); 
			sorted.remove(sorted[i]);
		}
	}
}

// preemptive scheduling , use RR with a time slice of 1 quantum for each priority queue
// nonpreemptive scheduling , use FCFS

